<snippet>
	<content><![CDATA[
namespace FFT {
#define fore(i, a, b) for(int i = (int)(a); i <= (int)(b); ++i)
#define forn(i, n) for(int i = 0; i < (int)(n); ++i)
    typedef long double ld;
    struct base {
        typedef double T; T re, im;
        base() :re(0), im(0) {}
        base(T re) :re(re), im(0) {}
        base(T re, T im) :re(re), im(im) {}
        base operator + (const base& o) const { return base(re + o.re, im + o.im); }
        base operator - (const base& o) const { return base(re - o.re, im - o.im); }
        base operator * (const base& o) const { return base(re * o.re - im * o.im, re * o.im + im * o.re); }
        base operator * (ld k) const { return base(re * k, im * k) ;}
        base conj() const { return base(re, -im); }
    };
    const int N = 21;
    const int MAXN = (1<<N);
    base w[MAXN];
    base f1[MAXN];
    int rev[MAXN];
    int size(auto v){
        return v.size();
    }

    void build_rev(int k) {
        static int rk = -1;
        if( k == rk )return ; rk = k;
        fore(i, 1, (1<<k) ) {
            int j = rev[i-1], t = k-1;
            while( t >= 0 && ((j>>t)&1) ) { j ^= 1 << t; --t; }
            if( t >= 0 ) { j ^= 1 << t; --t; }
            rev[i] = j;
        }
    }
    void fft(base *a, int k) {
        build_rev(k); int n = 1 << k;
        forn(i, n) if( rev[i] > i ) swap(a[i], a[rev[i]]);
        for(int l = 2, ll = 1; l <= n; l += l, ll += ll) {
            if( w[ll].re == 0 && w[ll].im == 0 ) {
                ld angle = M_PI / ll;
                base ww( cosl(angle), sinl(angle) );
                if( ll > 1 ) for(int j = 0; j < ll; ++j) {
                    if( j & 1 ) w[ll + j] = w[(ll+j)/2] * ww;
                    else w[ll + j] = w[(ll+j)/2];
                } else w[ll] = base(1, 0);
            }
            for(int i = 0; i < n; i += l) forn(j, ll) {
                base v = a[i + j], u = a[i + j + ll] * w[ll + j];
                a[i + j] = v + u; a[i + j + ll] = v - u;
            }
        }
    }
    vector<lli> mul(const vector<lli>& a, const vector<lli>& b) {
        int k = 1;
        while( (1<<k) < (size(a) + size(b)) ) ++k;
        int n = (1<<k);
        forn(i, n) f1[i] = base(0,0);
        forn(i, a.size()) f1[i] = f1[i] + base(a[i], 0);
        forn(i, b.size()) f1[i] = f1[i] + base(0, b[i]);
        fft(f1, k);
        forn(i, 1 + n/2) {
            base p = f1[i] + f1[(n-i)%n].conj();
            base _q = f1[(n-i)%n] - f1[i].conj();
            base q(_q.im, _q.re);
            f1[i] = (p * q) * 0.25;
            if( i > 0 ) f1[(n - i)] = f1[i].conj();
        }
        forn(i, n) f1[i] = f1[i].conj();
        fft(f1, k);
        vector<lli> r(size(a) + size(b));
        forn(i, size(r) ) {
            r[i] = ((lli)(f1[i].re / n + 0.5));
        }
        return r;
    }
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>fft</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
